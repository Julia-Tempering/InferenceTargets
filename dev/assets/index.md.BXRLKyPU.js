import{_ as a,c as t,o as i,aA as s}from"./chunks/framework.Uk63vj1k.js";const p=JSON.parse('{"title":"InferenceTargets","description":"","frontmatter":{},"headers":[],"relativePath":"index.md","filePath":"index.md","lastUpdated":null}'),n={name:"index.md"};function o(r,e,l,h,d,c){return i(),t("div",null,[...e[0]||(e[0]=[s('<h1 id="InferenceTargets" tabindex="-1"><code>InferenceTargets</code> <a class="header-anchor" href="#InferenceTargets" aria-label="Permalink to &quot;`InferenceTargets` {#InferenceTargets}&quot;">​</a></h1><h2 id="Overview" tabindex="-1">Overview <a class="header-anchor" href="#Overview" aria-label="Permalink to &quot;Overview {#Overview}&quot;">​</a></h2><p><code>InferenceTargets</code> has two audiences in mind:</p><ol><li><p>Researchers developing and benchmarking algorithms to approximate probability distributions (&quot;targets&quot;, e.g., high-dimensional posterior distributions).</p></li><li><p>Users of these algorithms (e.g., Bayesian statisticians) that have encountered a challenging problem that they would like to share.</p></li></ol><p>The goal of the package is to facilitate exchange between these two groups. It has two main features. First, for audience (1), making it easy to pull sets of targets. Second, for audience (2), registering one or several challenging targets. We start with some terminology, then explain how to use the package for each of the two audiences.</p><h2 id="Terminology" tabindex="-1">Terminology <a class="header-anchor" href="#Terminology" aria-label="Permalink to &quot;Terminology {#Terminology}&quot;">​</a></h2><p>A <code>target</code> is an object encoding a probability distribution we seek to approximate. For example, some targets might conform the <a href="https://github.com/tpapp/LogDensityProblems.jl" target="_blank" rel="noreferrer">LogDensityProblems</a> interface, but <code>InferenceTargets</code> does not impose any restrictions on the targets&#39; Type.</p><p>A <code>target collection</code> is a git repository containing a Julia Module specifying one or several targets.</p><p>The <code>target registry</code> is a database in several target collections.</p><p>A <code>targetId</code> is a <code>Symbol</code> identifier for a <code>target</code>. The id should be unique within one collection, but not necessarily across collections.</p><h2 id="Audience-1:-Using-InferenceTargets-to-benchmark-an-algorithm-on-many-targets" tabindex="-1">Audience 1: Using <code>InferenceTargets</code> to benchmark an algorithm on many targets <a class="header-anchor" href="#Audience-1:-Using-InferenceTargets-to-benchmark-an-algorithm-on-many-targets" aria-label="Permalink to &quot;Audience 1: Using `InferenceTargets` to benchmark an algorithm on many targets {#Audience-1:-Using-InferenceTargets-to-benchmark-an-algorithm-on-many-targets}&quot;">​</a></h2><p>First, browse the <code>targets registry</code> to the collection of your choice: follow this <a href="https://julia-tempering.github.io/InferenceTargets/dev/generated/PosteriorDBTargets" target="_blank" rel="noreferrer">link</a> to see an example of a collection in the registry, and from that page, the navigation panel shows other such collections.</p><p>Each <code>target collection</code>&#39;s page has a documentation page with all the information you need to use the targets in that collection.</p><p>The interface to access all these targets is unified: see the <a href="https://julia-tempering.github.io/InferenceTargets/dev/reference" target="_blank" rel="noreferrer">Reference page</a>.</p><h2 id="Audience-2:-Adding-a-benchmark-problem" tabindex="-1">Audience 2: Adding a benchmark problem <a class="header-anchor" href="#Audience-2:-Adding-a-benchmark-problem" aria-label="Permalink to &quot;Audience 2: Adding a benchmark problem {#Audience-2:-Adding-a-benchmark-problem}&quot;">​</a></h2><p>We assume you have pushed to github a standard Julia package that incorporates the dependencies needed to run your problem. Your package does <strong>not</strong> have to be registered.</p><p>You do <strong>not</strong> need to add <code>InferenceTargets</code> as a dependency. We instead rely on simple function name conventions. There are two methods to declare targets: (a) if you have one or a small list of targets, use the &quot;dispatch style&quot; convention; (b) if you have a very long list of targets, use the &quot;provided ids style&quot;. You should pick only one of these two styles.</p><h3 id="One-or-a-small-list-of-targets" tabindex="-1">One or a small list of targets <a class="header-anchor" href="#One-or-a-small-list-of-targets" aria-label="Permalink to &quot;One or a small list of targets {#One-or-a-small-list-of-targets}&quot;">​</a></h3><p>We will define a function named <code>provide_target</code>. Each dispatch should take an argument of type <code>Val{:my_target_id}</code> and return the target. For example:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">provide_target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Val{:my_target_id}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> some_code</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># my code constructing a target</span></span></code></pre></div><p>Once you are done, skip to section &quot;Addding your collection to the registry&quot;</p><h3 id="Long-lists-of-targets" tabindex="-1">Long lists of targets <a class="header-anchor" href="#Long-lists-of-targets" aria-label="Permalink to &quot;Long lists of targets {#Long-lists-of-targets}&quot;">​</a></h3><p>Define a function called <code>provide_targetIds()</code> which should return an iterable over <code>Symbol</code>s:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">provide_targetIds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:first_id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:second_id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># would typically lookup in a database</span></span></code></pre></div><p>Then, define a function called <code>provide_target</code> that takes a <code>Symbol</code> and returns the target:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> provide_target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(targetId</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Symbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> some_code</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># load from a database, construct target</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><h3 id="Adding-your-collection-to-the-registry" tabindex="-1">Adding your collection to the registry <a class="header-anchor" href="#Adding-your-collection-to-the-registry" aria-label="Permalink to &quot;Adding your collection to the registry {#Adding-your-collection-to-the-registry}&quot;">​</a></h3><p>Commit and push your changes. Then, create a PR adding one line pointing to your repo in this <a href="https://github.com/Julia-Tempering/InferenceTargets/blob/main/src/targets_registry.jl" target="_blank" rel="noreferrer">file</a>.</p><p>After your PR is merged, the registry documentation page will automatically be generated for your collection.</p><hr><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl" target="_blank" rel="noreferrer">Literate.jl</a>.</em></p>',31)])])}const u=a(n,[["render",o]]);export{p as __pageData,u as default};
