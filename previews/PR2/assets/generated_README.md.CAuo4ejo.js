import{_ as t,c as a,o as r,aA as n}from"./chunks/framework.D7a-xEaM.js";const p=JSON.parse('{"title":"InferenceTargets.jl － Benchmarknought","description":"","frontmatter":{},"headers":[],"relativePath":"generated/README.md","filePath":"generated/README.md","lastUpdated":null}'),o={name:"generated/README.md"};function i(s,e,c,l,d,h){return r(),a("div",null,[...e[0]||(e[0]=[n('<h1 id="InferenceTargets.jl-－-Benchmarknought" tabindex="-1"><code>InferenceTargets.jl</code> － Benchmarknought <a class="header-anchor" href="#InferenceTargets.jl-－-Benchmarknought" aria-label="Permalink to &quot;`InferenceTargets.jl` － Benchmarknought {#InferenceTargets.jl-－-Benchmarknought}&quot;">​</a></h1><p>&lt;!– Warning: make sure you edit the .jl file, not the .md file! The latter are generated and will get overwritten. –&gt;</p><h2 id="Overview" tabindex="-1">Overview <a class="header-anchor" href="#Overview" aria-label="Permalink to &quot;Overview {#Overview}&quot;">​</a></h2><p><code>InferenceTargets.jl</code> has two audiences in mind:</p><ol><li><p>Researchers developing and benchmarking algorithms to approximate probability distributions (&quot;targets&quot;, e.g., high-dimensional posterior distributions).</p></li><li><p>Users of these algorithms (e.g., Bayesian statisticians) that have encountered a challenging problem.</p></li></ol><p>The goal of the package is to facilitate exchange between these two groups. It has two main features. First, for audience (1), making it easy to pull sets of targets. Second, for audience (2), registering one or several challenging targets. We start with some terminology, then explain how to use the package for each of the two audiences.</p><h2 id="Terminology" tabindex="-1">Terminology <a class="header-anchor" href="#Terminology" aria-label="Permalink to &quot;Terminology {#Terminology}&quot;">​</a></h2><p>A <code>target</code> is an object encoding a probability distribution we seek to approximate. For example, some targets might conform the <a href="https://github.com/tpapp/LogDensityProblems.jl" target="_blank" rel="noreferrer">LogDensityProblems</a> interface if they are fully continous, but there are no restrictions on the type of targets.</p><p>A <code>target collection</code> is a git repository containing a Julia Module specifying one or several targets. Here is an example:</p><p>The <code>target registry</code> is a dictionary that lists several target collections.</p><p>A <code>targetId</code> is a <code>Symbol</code> identifier for a <code>target</code>. Within one collection, it should be unique, but not necessarily across collections.</p><h2 id="Audience-1:-Using-InferenceTargets.jl-to-setup-a-benchmark" tabindex="-1">Audience 1: Using <code>InferenceTargets.jl</code> to setup a benchmark <a class="header-anchor" href="#Audience-1:-Using-InferenceTargets.jl-to-setup-a-benchmark" aria-label="Permalink to &quot;Audience 1: Using `InferenceTargets.jl` to setup a benchmark {#Audience-1:-Using-InferenceTargets.jl-to-setup-a-benchmark}&quot;">​</a></h2><h2 id="Audience-2:-Adding-a-benchmark-problem" tabindex="-1">Audience 2: Adding a benchmark problem <a class="header-anchor" href="#Audience-2:-Adding-a-benchmark-problem" aria-label="Permalink to &quot;Audience 2: Adding a benchmark problem {#Audience-2:-Adding-a-benchmark-problem}&quot;">​</a></h2><p>We assume you have pushed to github a standard Julia package that incorporates the dependencies needed to run your problem, but we do <strong>not</strong> assume your package is registered.</p><p>You do <strong>not</strong> need to add <code>InferenceTargets</code> as a dependency. We instead rely on a convention for function names. There are two methods to declare targets: if you have one or a small list of targets</p><hr><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl" target="_blank" rel="noreferrer">Literate.jl</a>.</em></p>',17)])])}const u=t(o,[["render",i]]);export{p as __pageData,u as default};
